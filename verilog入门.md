# verilog入门

## 1.verilog模块结构

| **模块部分**                          | **内容**                     |
| ------------------------------------- | ---------------------------- |
| **module 模块名 ([端口列表]);**       |                              |
| [端口信号声明:]                       |                              |
| [参数声明:]                           |                              |
| **内部信号声明**                      | **assign语句**               |
| **底层模块或门原语调用 (包括生成块)** | **Initial 或 always 语句块** |
| **任务和函数定义**                    | **specify 块 (路径延迟)**    |
| **endmodule**                         |                              |

常见语句主要有以下三种：

- `assign` 语句
- `always` 语句
- 底层模块调用语句

**语句顺序**：

- 三种语句的顺序无关，彼此独立。

**模块结构必备部分**：

- 除开头的 `module` 模块名和结尾的 `endmodule` 是必须的外，其它部分都是可选的。

### 例一.二选一数据选择器

#### 1.**二选一数据选择器的描述**

- 功能：
  - 选择两个输入信号中的一个作为输出。
  - 根据选择信号 `s` 的状态选择输入 `a` 或 `b`。

#### **2. 二选一数据选择器的符号**

- **输入端**：
  - `a` 和 `b`：数据输入信号。
  - `s`：选择信号。
- **输出端**：
  - `y`：输出信号。
- **功能描述**：
  - 当选择信号 `s=0` 时，输出 `y=a`。
  - 当选择信号 `s=1` 时，输出 `y=b`。

二选一数据选择器的符号

```text
        s
        |
        |
   +----|----+
   |         |
   |    MUX  |
   |         |
   +----+----+
        |
        y
    ----|----
        |
   +----+----+
   |         |
 a |         | b
```

#### 3.**二选一数据选择器的结构之一**

- 逻辑电路结构：
  - 包括：
    - 一个 **NOT 门**：对选择信号 `s` 进行反相。
    - 两个 **AND 门**：分别与输入信号 `a` 和 `b` 配合。
    - 一个 **OR 门**：汇总 AND 门的输出，得到最终的 `y`。
  - 工作原理：
    - 当 `s=0`，NOT 门输出高电平，使得 `y=a`。
    - 当 `s=1`，直接使 `y=b`。

```text
   a -----------+-----[AND]---+
                 |             |
                 |             +---[OR]--- y
                 |             |
   b ----[AND]---+             |
                              [NOT]
                                |
                                s
```

#### 4.二选一多路选择器的verilog描述

```verilog
module MUX21a (a, b, s, y);
    input a, b, s;
    output y;

    assign y = (s ? a : b);
endmodule
```

**代码解析：**

1. **模块名称**：

   - `MUX21a`：表示一个二选一多路选择器模块。

2. **端口列表**：

   - 输入信号：
     - `a` 和 `b`：选择器的两个数据输入。
     - `s`：控制选择信号。
   - 输出信号：
     - `y`：选择的输出信号。

3. **逻辑功能**：

   - 使用三元运算符 

     ```
     s ? a : b
     ```

      实现数据选择：

     - 当 `s = 1` 时，`y = a`。
     - 当 `s = 0` 时，`y = b`。

### 例二.边沿D触发器

#### 1.电路描述

```text
       +---------+
CLK -->|         |
       |   DFF   |--> Q
 D  -->|         |
       +---------+
```

**电路图描述（文字形式）**

1. **输入信号**：
   - `D`：数据输入。
   - `CLK`：时钟输入，触发数据更新。
2. **内部逻辑**：
   - 一个 D 触发器，根据 `CLK` 的上升沿触发，存储并输出数据 `D`。
3. **输出信号**：
   - `Q`：存储的输出值。

#### 2.代码

```verilog
module DFF1 (CLK, D, Q);
    output Q;
    input CLK, D;
    reg Q;

    always @(posedge CLK) 
        Q <= D;
endmodule
```

**代码解析**

1. **模块名称**：
   - `DFF1` 表示一个边沿触发的 D 触发器。
2. **端口声明**：
   - `CLK`：时钟信号输入，用于触发数据更新。
   - `D`：数据输入。
   - `Q`：数据输出。
3. **信号类型**：
   - `Q` 被声明为 `reg` 类型，因为在 `always` 块中进行赋值。
4. **逻辑描述**：
   - 在 `always` 块中，使用 `@(posedge CLK)` 指定上升沿触发。
   - `Q <= D` 表示非阻塞赋值，更新触发器的输出为输入数据 `D`。

## 2.模块说明部分

#### 模块声明格式：

```verilog
module 模块名 ([端口列表]);
    [端口信号声明:]
    [参数声明:]
endmodule
```

- **输入输出属性 数据类型 位宽 名称**
  输入信号属性包括 `input`，输出信号属性包括 `output`，可选信号类型为 `wire` 或 `reg`。
- **parameter 数据类型 参数名 = 初值**
  参数声明可以通过 `parameter` 定义参数名称、数据类型和初始值。

------

#### **模块说明内容：**

1. **模块名**
   - 模块名是指电路的名字，由用户指定，最好与文件名一致（特别是在 Quartus II 软件中调试时）。
2. **端口列表**
   - 指电路的输入/输出信号名称列表，信号名由用户指定，各名称间用逗号隔开。
3. **端口信号声明**
   - 说明端口信号的输入输出属性、信号的数据类型，以及信号的位宽：
     - 输入输出属性有 `input`、`output`、`inout` 三种。
     - 信号的数据类型常用的有 `wire` 和 `reg` 两种。
     - 信号的位宽用 `[n1:n2]` 表示，同一类信号之间用逗号隔开。
4. **参数声明**
   - 参数声明要说明参数的名称和初值。

#### 例

```verilog
module full_adder (A, B, CIN, S, COUT);
    input [3:0] A, B;
    input CIN;
    output reg [3:0] S;
    output COUT;
endmodule
```

#### 关键知识点

1. **位宽默认值**：
   - 如果位宽没有做说明，默认是 **1 位**。
2. **数据类型默认值**：
   - 如果数据类型没有做说明，默认是 **`wire` 型**。
3. **信号位宽**：
   - 信号 `S` 的位宽为 4 位，对应信号为 `S[3]`、`S[2]`、`S[1]` 和 `S[0]`。

## 3.assign语句

#### **`assign` 语句称作连续赋值语句**

##### **基本格式**

```verilog
assign 赋值目标 = 表达式;
```

------

##### **示例代码**

```verilog
assign y = a;
assign y = a & b;
```

- 图示解释：
  - `assign y = a;`：直接将信号 `a` 赋值给 `y`。
  - `assign y = a & b;`：将信号 `a` 和 `b` 的按位与操作结果赋值给 `y`。

------

##### **特点**

1. **连续赋值语句**：
   - 是指赋值总是处于激活状态，只要表达式中的操作数有变化，立即进行计算和赋值。
   - 与 `always` 块中的过程赋值语句不同，`assign` 是针对 **组合逻辑** 的描述。
2. **赋值目标**：
   - 必须是 `wire` 类型的变量。
   - `wire` 表示电路的连接线，不能用 `reg` 类型作为目标。

#### 可用于assign语句的表达式

##### 表 1: Verilog 运算符和操作功能

| **操作类型** | **操作符** | **执行的操作** |
| ------------ | ---------- | -------------- |
| 算术         | `*`        | 乘             |
|              | `/`        | 除             |
|              | `+`        | 加             |
|              | `-`        | 减             |
|              | `%`        | 取模           |
|              | `**`       | 求幂           |
| 逻辑         | `!`        | 逻辑求反       |
|              | `&&`       | 逻辑与         |
|              | `||`       | 逻辑或         |
| 关系         | `>`        | 大于           |
|              | `<`        | 小于           |
|              | `>=`       | 大于等于       |
|              | `<=`       | 小于等于       |
| 等价         | `==`       | 相等           |
|              | `!=`       | 不等           |
|              | `===`      | case 相等      |
|              | `!==`      | case 不等      |

##### 表 2: Verilog 其他运算功能

| **操作类型** | **操作符**  | **执行的操作** |
| ------------ | ----------- | -------------- |
| 按位         | `~`         | 按位求反       |
|              | `&`         | 按位与         |
|              | `|`         | 按位或         |
|              | `^`         | 按位异或       |
|              | `^~` / `~^` | 按位同或       |
| 缩减         | `&`         | 缩减与         |
|              | `~&`        | 缩减与非       |
|              | `|`         | 缩减或         |
|              | `~|`        | 缩减或非       |
|              | `^`         | 缩减异或       |
|              | `^~` / `~^` | 缩减同或       |
| 移位         | `>>`        | 右移           |
|              | `<<`        | 左移           |
|              | `>>>`       | 算术右移       |
|              | `<<<`       | 算术左移       |
| 拼接         | `{}`        | 拼接           |
| 复制         | `{{}}`      | 复制           |
| 条件         | `?:`        | 条件           |

**说明：**

1.算术型

加减乘除、求幂的操作数可以是实数也可以是整数，求余运算的操作数只能是整数。

求余运算结果取第一个操作数的符号。

2.逻辑型

**逻辑型运算的结果**可能是：

- `1`（逻辑真）、
- `0`（逻辑假）、
- `x`（不确定）。

**逻辑运算的操作数**可以是任意表达式，表达式的结果被当做逻辑值处理，只有 `1`、`0`、`x` 三种情况：

- 非 `0` 的值即为 `1`；
- `0` 表示逻辑假；
- `x` 表示不确定。

**建议**：表达式最好加括号。

3.关系运算符

关系运算符的结果可能是1，0，x

4.等价运算符

**等于和不等于运算的结果**可能是：

- `1`（逻辑真）、
- `0`（逻辑假）、
- `x`（不确定）。
- 对于 `x` 或 `z`，认为是不确定的值，比较结果为 `x`。

**case 等于和 case 不等的结果**只能是：

- `1` 或 `0`，
- 对于 `x`、`z` 认为是确定的值，参与比较。

5.按位运算符

**按位运算的操作数**是 1 位或多位二进制数。

**按位非的操作数**只有一个，将该数的每一位求非运算。

**其它按位运算的操作数**有 2 个或多个，将两个操作数对应的位两两运算。

如果操作数位宽不同，位宽小的会自动左添 0 补齐。

**结果与操作数位宽相同**。

6.缩减运算符

**缩减运算的操作数**是 1 位或多位二进制数。

**缩减运算的操作数**只有一个，将该数的各位自左至右进行逻辑运算，结果只有一位。

7.移位运算符

格式：操作数 移位符 n;

**移位运算的操作数**是 1 位或多位二进制数。

**向左或向右移 n 位**。

只有对有符号数的算术右移自动补符号位。

其他移位均自动补 0。

8.拼接复制运算符

拼接：格式 {操作数1，操作数2,...}

复制拼接：格式 {n{操作数1，操作数2，...}}

将多个操作数拼接起来；

将操作数复制 `n` 遍并拼接起来；

可以组合使用。

9.条件运算符

格式：表达式1？表达式2：表达式3

根据表达式1的值，决定运算结果：

- 如果表达式1值为1，则结果等于表达式2；
- 如果表达式1值为0，则结果等于表达式3；
- 如果表达式1值为x，则结果为x。

可以嵌套。

## 4.always语句块

`always`语句块，也称为过程块。

1. **基本格式**：
   - `always @(敏感信号条件表)`：定义敏感信号列表，当这些信号发生变化时，`always`块中的语句会被执行。
   - 各类顺序语句：在`always`块中可以包含顺序执行的语句。
2. **示例**：
   - `always @(posedge CLK) Q = D;`
   - 这个例子表示在时钟信号CLK的上升沿（posedge）时，将D的值赋给Q。
3. **特点**：
   - `always`语句本身不是单一的有意义的一条语句，而是和下面的语句一起构成一个语句块，称之为过程块；过程块中的赋值语句称过程赋值语句。
   - 该语句块不是总处于激活状态，当满足激活条件时才能被执行，否则被挂起，挂起时即使操作数有变化，也不执行赋值，赋值目标值保持不变。
   - 赋值目标必须是`reg`型的。

激活条件由敏感信号条件表决定，当敏感条件满足时，过程块被激活

敏感条件有两种，一种是边沿敏感，一种是电平敏感。

边沿敏感和电平敏感两种类型：

1. **边沿敏感**：
   - `posedge 信号名`：表示信号的上升沿，即信号从低电平变为高电平时触发。
   - `negedge 信号名`：表示信号的下降沿，即信号从高电平变为低电平时触发。
   - 例子：
     - `posedge clk`：在时钟信号`clk`的上升沿触发。
     - `negedge clk`：在时钟信号`clk`的下降沿触发。
2. **电平敏感**：
   - `(信号名列表)`：表示信号列表中的任何一个信号发生变化时触发。
   - 例子：
     - `(a, b, c)`：当信号`a`、`b`或`c`中的任何一个发生变化时触发。
   - 说明：逗号可以换成逻辑或操作符`or`，即`(a or b or c)`，效果相同。

### 边沿触发（posedge CLK）

1. **代码示例**：

   ```verilog
   always @(posedge CLK)
       Q = D;
   ```

   这段代码表示，当时钟信号`CLK`出现上升沿（从低电平变为高电平）时，触发`always`语句块，将输入信号`D`的值赋给输出信号`Q`。

2. **工作原理**：

   - 当`CLK`的上升沿到来时，`always`语句块被激活，执行赋值操作，即将`D`的值赋给`Q`。
   - 如果`CLK`没有上升沿，即使`D`的值发生变化，`Q`的值也不会改变，直到下一个`CLK`的上升沿到来。

```lua
       +-------------------+
       |                   |
 D --->|                   |---> Q
       |   D Flip-Flop     |
 CLK-->|                   |---> Q'
       |                   |
       +-------------------+
```

**说明：**

- **D** 是数据输入端，连接到触发器的输入。
- **CLK** 是时钟输入端，控制触发器何时更新输出。
- **Q** 是数据输出端，保存最新的输入值。
- **Q'** 是 **Q** 的反向输出（如果需要反向输出，可以使用该端口）。

在时钟信号的上升沿，D触发器将 **D** 的当前值锁存并输出到 **Q**，保持不变直到下一个时钟上升沿。

### 电平触发（D）

1. **代码示例**：

   ```verilog
   always @(D)
       Q = D;
   ```

   这段代码表示，当输入信号`D`发生变化时（无论是从1变为0还是从0变为1），触发`always`语句块，将`D`的值赋给`Q`。

2. **工作原理**：

   - 只要`D`的值发生变化，`always`语句块就会被激活，执行赋值操作，即将`D`的新值赋给`Q`。
   - 如果`D`的值保持不变，即使有其他信号变化，`Q`的值也不会改变，直到`D`再次变化。

```lua
     +---+
 D   |   |  Q
 --->|   |--->
     |   |
     +---+

```

**说明：**

- **D** 是输入端，表示输入信号。
- **Q** 是输出端，表示输出信号。
- 这只是一个 **直接连接** 的组合逻辑电路，没有任何时序元件（例如触发器或寄存器）。当 **D** 改变时，**Q** 会立即改变，**Q** 的值始终等于 **D**。

### 说明：

1. **赋值目标类型**：
   - 过程块中的赋值目标必须是`reg`型的。这意味着在`always`块中，赋值操作的左侧变量必须是`reg`类型，这是Verilog中用于存储值的寄存器类型。
2. **应用场景**：
   - `always`语句可以描述信号的边沿变化，因此在设计时序电路中得到广泛应用。时序电路的逻辑状态会随着时间的变化而变化，`always`块能够很好地描述这种变化。
3. **增强功能**：
   - `always`语句中还可以使用`if`、`case`、`for`循环等语句，这些控制语句使得`always`块的功能更加强大，能够实现更复杂的逻辑控制。

**示例：**

1. **边沿触发示例**：

   ```verilog
   always @(posedge CLK)
       Q <= D;
   ```

   - 这个例子表示，当时钟信号`CLK`出现上升沿时，将输入信号`D`的值赋给输出信号`Q`。这里使用了非阻塞赋值操作符`<=`，这是在时序逻辑中常用的赋值方式，以确保所有赋值操作在时钟周期的同一时刻发生。

2. **电平触发示例**：

   ```verilog
   always @(D)
       Q <= D;
   ```

   - 这个例子表示，当输入信号`D`发生变化时，将`D`的值赋给输出信号`Q`。这里同样使用了非阻塞赋值操作符`<=`。

**必须是`reg`型的解释：**

- 在Verilog中，`reg`类型用于定义存储元素，如寄存器或存储单元。在`always`块中，赋值目标必须是`reg`型，因为这些元素能够存储值并在程序的后续部分被访问或修改。
- 使用`reg`类型也有助于区分组合逻辑和时序逻辑。在时序逻辑中，信号的变化与时间有关，通常与时钟信号相关联。

### `assign`语句和`always`语句的主要区别

**主要区别：**

1. **激活状态**：
   - `assign`语句是连续赋值语句，它总是处于激活状态。这意味着只要操作数（如`D`）发生变化，`assign`语句会立即进行计算并更新赋值目标（如`Q`）的值。
   - `always`语句是过程赋值语句，它只有在特定条件下（如时钟上升沿）被激活时，才会进行计算和赋值。如果过程不被激活，即使操作数发生变化，也不会进行计算和赋值。
2. **赋值目标类型**：
   - 在`assign`语句中，赋值目标必须是`wire`型。`wire`类型用于连续赋值，表示信号的物理连接，其值由赋值语句或模块实例化决定。
   - 在`always`语句中，赋值目标必须是`reg`型。`reg`类型用于存储值，可以被过程赋值语句（如`always`块）赋值，其值在过程块激活时更新。

**示例：**

1. **连续赋值语句**：

   ```verilog
   assign Q = D;
   ```

   - 这个例子中，只要`D`的值发生变化，`Q`的值会立即更新。`Q`必须是`wire`型。

2. **过程赋值语句**：

   ```verilog
   always @(posedge clk)
       Q <= D;
   ```

   - 这个例子中，只有在时钟信号`clk`的上升沿到来时，`always`块才会被激活，然后`Q`的值才会更新为`D`的值。如果`clk`没有上升沿，即使`D`发生变化，`Q`的值也不会更新。`Q`必须是`reg`型。

- `always`语句块不仅可以使用表达式赋值，还可以使用`if`、`case`等行为描述语句，以及描述边沿变化。这使得`always`语句块的功能比`assign`语句更强大。`assign`语句不能使用`if`等语句，也不能描述边沿变化。

```verilog
module DFF2 (CLK, D, Q, RST, EN)
input CLK, D, RST, EN;
output Q;
reg Q;
always @(posedge CLK or negedge RST)
begin
    if (!RST) Q <= 0;
    else if (EN) Q <= D;
end
endmodule
```

模块的行为如下：

- 当复位信号`RST`为低电平（逻辑0）时，输出`Q`被置为0。
- 如果复位信号`RST`不是低电平，并且使能信号`EN`为高电平（逻辑1），则输出`Q`将跟随数据输入`D`的值。
- `always`语句块在时钟信号`CLK`的上升沿或复位信号`RST`的下降沿触发。
- 输出`Q`是一个`reg`类型的变量，因为它在`always`块中被赋值。

### 使用`begin`和`end`：

- 在`always`语句块中，如果有多条赋值语句，必须使用`begin`和`end`关键字将这些语句括起来。这样做可以清晰地定义语句块的开始和结束，使得代码更加易于理解和维护。
- 与`always`语句块不同，`assign`语句中没有`begin`和`end`关键字，因为`assign`通常只包含单个赋值操作。

```verilog
module adder (a, b, cin, s, cout);
input a, b, cin;
output s, cout;
reg s, cout;
always @(a, b, cin)
begin
    s = a ^ b ^ cin;
    cout = (a & b) | (a & cin) | (b & cin);
end
endmodule
```

模块的行为如下：

- 输入端口：`a`, `b`, `cin`（两个加数和一个进位输入）。
- 输出端口：`s`（和），`cout`（进位输出）。
- `reg s, cout;`：定义了两个`reg`类型的变量`s`和`cout`，用于存储和输出。
- `always @(a, b, cin)`：定义了一个`always`语句块，它在输入信号`a`, `b`, `cin`的任何变化时触发。
- begin ... end：包含了两个赋值语句，分别计算和s和进位cout：
  - `s = a ^ b ^ cin;`：计算输入信号的异或（XOR），得到和输出`s`。
  - `cout = (a & b) | (a & cin) | (b & cin);`：使用布尔代数计算进位输出`cout`，即当两个输入信号中至少有一个为1时，产生进位。

### 举例比较

设A、B同时由0变1

激活前：M1=0，M2=0，Q=0

激活后：

**阻塞赋值（例8-6）：**

```verilog
always @(A, B)
begin
    M1 = A;
    M2 = B & M1;
    Q = M1 | M2;
end
```

阻塞赋值（例8-6）：

- 先计算A=1，马上赋值给M1
- 再计算B&M1=1，马上赋值给M2
- 再计算M1|M2=1，马上赋值给Q

**非阻塞赋值（例8-7）：**

```verilog
always @(A, B)
begin
    M1 <= A;
    M2 <= B & M1;
    Q <= M1 | M2;
end
```

非阻塞赋值（例8-7）：

- 先计算A=1，（等待，不赋值）
- 再计算B&M1=0，（等待，不赋值）
- 再计算M1|M2=0，（等待，不赋值）
- 过程结束
- 先赋值给M1=1
- 再赋值给M2=0
- 再赋值给Q=0

不建议在一个always块中混合使用阻塞赋值和非阻塞赋值

### 综合举例：4位二进制加法计数器

```verilog
module CNT4 (CLK, Q);
input CLK;
output [3:0] Q;
reg [3:0] Q1;

always @(posedge CLK)
begin
    Q1 <= Q1 + 1;
end

assign Q = Q1;
endmodule
```

此程序中有`always`和`assign`两条语句，他们之间是并行的； 此程序中有一个内部变量`Q1`，使用时要进行声明；

内部信号声明格式： 数据类型 位宽 信号名称 元素个数

## 5.底层模块和门原语调用

### 1.底层调用

```lua
       +---+      +---+           +---+
 d --->|D  |----->|D  |----->     |   |
       |FF |      |FF |           | OR|
       +---+      +---+           |   |----> q
         |          |             +---+
         |          |
    a----+         |
                   clk
```

该电路是由两个D触发器和一个或门构成的，设计思路之一是先设计底层电路D触发器，然后再设计顶层电路，在顶层电路中可调用底层模块。

**底层模块描述（DFF模块）：**

```verilog
module DFF(CLK, D, Q)
    output reg Q;
    input CLK, D;
    always @(posedge CLK)
        Q <= D;
endmodule
```

底层模块调用格式：

- 底层模块名 例化名(端口映射);

电路图

```lua
    +---+
 d  |   |   q
--->| D |--->| Q
    | F |     |
 clk|   |     |
--->|   |<----+
    +---+
```

**顶层模块描述（examp模块）：**

```verilog
module examp(clk, d, a, q)
    output q;
    input clk, d, a;

    wire d1;
    wire q1;

    DFF dff1(.CLK(clk), .D(d1), .Q(q1));
    //DFF dff2(.Q(q1), .D(d), .CLK(clk));这个写法不好
    or (d1, a, q);
endmodule
```

顶层模块描述：

- 为了调用底层模块，需要加两个内部变量`d1`和`q1`。
- 并给两次调用的模块进行命名；调用时例化名不能省略。

电路图

```lua
       +---+        +---+
d1 --->| D |----->  | D |-----> q
       | F |  q1    | F |
clk--->| F |        | F |
       +---+        +---+
         |            |
         +------------+
              |
              a
```

### 2.端口映射

端口映射有两种方法：

端口名关联法(命名法)

位置关联法(顺序法)

命名法格式： (底层端口名1(外接信号名1),..底层端口名2(外接信号名2),...)

```verilog
DFF dff1(.CLK(clk), .D(d1), .Q(q1));
```

因为有名字对应，不必按底层模块的端口信号列表顺序

顺序法格式： (外接信号名1,外接信号名2,...)

```verilog
DFF dff2(q1, d, q);
```

必须严格按照底层模块的端口信号列表顺序书写

### 3.门原语

Verilog语言提供已经设计好的门，称为门原语（primitive，共12个），这些门可直接调用，不用再对其进行功能描述。

门原语调用格式：

```text
门原语名 实例名（端口连接）
```

其中实例名可省略（和模块调用不同），端口连接只能采用顺序法，输出在前，输入在后。

例：`and (out, in1, in2);`

端口连接中第一个是输出，其余是输入，输入个数不限。

**与门等6个**

| and（与）    | or（或）    | xor（异或）  |
| :----------- | :---------- | :----------- |
| nand（与非） | nor（或非） | xnor（同或） |

### 4.非门和缓冲器

- **not（非门）**：逻辑非门，输入为`in`，输出为`out`。

```lua
       +---+
in --->|   |---> out
       |NOT|
       +---+
```

- **buf（缓冲器）**：逻辑缓冲器，输入为`in`，输出为`out`。

```lua
       +---+
in --->|   |---> out
       |BUF|
       +---+
```

**例：**

- `not(OUT1, IN);`：定义一个非门，其中`OUT1`是输出，`IN`是输入。
- `buf b1_2out(OUT1, OUT2, IN);`：定义一个缓冲器，具有两个输出`OUT1`和`OUT2`，以及一个输入`IN`。

端口列表中前面是输出，最后一个是输入，输出个数不限。

### 5.三态门

- **bufif1**（控制端1有效缓冲器）

```lua
       +---+  
in --->|   |---> out
       |BUF|
ctrl-->|   |
       +---+
```

- **bufif0**（控制端0有效缓冲器）

```lua
       +---+  
in --->|   |---> out
       |BUF|
ctrl-->|   |
       +---+
```

- **notif1**（控制端1有效非门）

```lua
       +---+  
in --->|   |---> out
       |NOT|
ctrl-->|   |
       +---+
```

- **notif0**（控制端0有效非门）

```lua
       +---+  
in --->|   |---> out
       |NOT|
ctrl-->|   |
       +---+
```

这些三态门的端口列表中，前面是输出，中间是输入，最后是使能端（ctrl），输出个数不限。

例：

```verilog
bufif1 b1(out, in, ctrl);
bufif0 b0(out, in, ctrl);
notif1 n1(out, in, ctrl);
notif0 n0(out, in, ctrl);
```



